name: Iran-Optimized Proxy Collector

permissions:
  contents: write

on:
  schedule:
    - cron: '0 */2 * * *' # Ù‡Ø± 2 Ø³Ø§Ø¹Øª (Ø¨Ø±Ø§ÛŒ ÙØ´Ø§Ø± Ú©Ù…ØªØ±)
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Dependencies
      run: |
        pip install requests

    - name: Run Optimization Script
      run: |
        rm -f sub_*.txt
        
        cat << 'EOF' > optimizer.py
        import requests
        import base64
        import json
        import re
        import socket
        import concurrent.futures
        import random

        # --- ØªÙ†Ø¸ÛŒÙ…Ø§Øª ---
        SOURCES = [
            {'url': 'https://chat.tawana.online/sub/tawanaproxy.txt', 'tag': 'skimia'},
            {'url': 'https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/EternityAirports_sub.txt', 'tag': 'public'},
            {'url': 'https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all_extracted_configs.txt', 'tag': 'public'},
        ]
        
        TIMEOUT = 3 # ØªØ§ÛŒÙ…â€ŒØ§ÙˆØª Ø±Ø§ Ø¨Ø§Ù„Ø§ Ø¨Ø±Ø¯ÛŒÙ… ØªØ§ Ø³Ø±ÙˆØ±Ù‡Ø§ÛŒ Ú©Ù†Ø¯ Ø­Ø°Ù Ù†Ø´ÙˆÙ†Ø¯
        MAX_WORKERS = 50
        LIMIT_PUBLIC = 50 # ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ù†ÙÛŒÚ¯ Ø¹Ù…ÙˆÙ…ÛŒ
        LIMIT_SKIMIA = 100 # ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ù†ÙÛŒÚ¯ Ø§Ø³Ú©ÛŒÙ…ÛŒØ§ (ØªÙ‚Ø±ÛŒØ¨Ø§ Ù‡Ù…Ù‡)

        def get_flag(country_code):
            if not country_code: return 'ğŸš©'
            return chr(127397 + ord(country_code[0])) + chr(127397 + ord(country_code[1]))

        def parse_config(config):
            try:
                # ØªØ´Ø®ÛŒØµ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÙˆÙ„ÙˆÛŒØªâ€ŒØ¯Ù‡ÛŒ
                security_score = 0
                if 'tls' in config or 'reality' in config: security_score += 2
                if ':443' in config or ':2053' in config or ':2083' in config: security_score += 1
                if 'vmess://' in config: security_score -= 1 # Ø§ÙˆÙ„ÙˆÛŒØª Ú©Ù…ØªØ± Ø¨Ù‡ vmess Ù…Ø¹Ù…ÙˆÙ„ÛŒ

                if config.startswith('vmess://'):
                    b64 = config[8:]
                    padding = len(b64) % 4
                    if padding: b64 += '=' * (4 - padding)
                    decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                    data = json.loads(decoded)
                    return {'type': 'vmess', 'ip': data['add'], 'port': int(data['port']), 'data': data, 'raw': config, 'score': security_score}
                
                elif any(config.startswith(p) for p in ['vless://', 'trojan://', 'ss://']):
                    ptype = config.split('://')[0]
                    match = re.search(r'://(?:.*@)?([\w\.-]+):(\d+)', config)
                    if match:
                        return {'type': ptype, 'ip': match.group(1), 'port': int(match.group(2)), 'raw': config, 'score': security_score}
            except: pass
            return None

        # ÙÙ‚Ø· Ú†Ú© Ù…ÛŒÚ©Ù†ÛŒÙ… Ø²Ù†Ø¯Ù‡ Ø§Ø³Øª ÛŒØ§ Ù†Ù‡ØŒ Ø³Ø±Ø¹Øª Ù…Ù‡Ù… Ù†ÛŒØ³Øª
        def is_alive(proxy_info):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(TIMEOUT)
                result = sock.connect_ex((proxy_info['ip'], proxy_info['port']))
                sock.close()
                return result == 0
            except:
                return False

        print('Downloading sources...')
        unique_configs = {}
        
        for source in SOURCES:
            try:
                resp = requests.get(source['url'], timeout=15)
                content = resp.text.strip()
                try:
                    if not '://' in content[:50]:
                        content = base64.b64decode(content).decode('utf-8', errors='ignore')
                except: pass
                
                for line in content.splitlines():
                    line = line.strip()
                    if not line: continue
                    info = parse_config(line)
                    if info:
                        info['source_tag'] = source['tag']
                        key = f"{info['ip']}:{info['port']}"
                        # Ø§Ú¯Ø± ØªÚ©Ø±Ø§Ø±ÛŒ Ø¨ÙˆØ¯ ÙˆÙ„ÛŒ Ø§Ø² Ø§Ø³Ú©ÛŒÙ…ÛŒØ§ Ø¨ÙˆØ¯ØŒ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ú©Ù†
                        if key not in unique_configs or source['tag'] == 'skimia':
                            unique_configs[key] = info
            except Exception as e:
                print(f'Error {source["url"]}: {e}')

        config_list = list(unique_configs.values())
        print(f'Total configs: {len(config_list)}')

        # Ø¯Ø±ÛŒØ§ÙØª GeoIP
        print('Getting GeoIP...')
        ips = list(set([c['ip'] for c in config_list]))
        ip_map = {}
        for i in range(0, len(ips), 100):
            try:
                batch = ips[i:i+100]
                resp = requests.post('http://ip-api.com/batch', json=[{'query': ip, 'fields': 'query,country,countryCode'} for ip in batch], timeout=15)
                for item in resp.json():
                    if 'country' in item: ip_map[item['query']] = item
            except: pass

        # ØªØ³Øª Ø³Ù„Ø§Ù…Øª (ÙÙ‚Ø· Ø²Ù†Ø¯Ù‡ Ø¨ÙˆØ¯Ù†)
        print('Checking health...')
        valid_configs = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            # Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ù†ØªÛŒØ¬Ù‡ ÙÛŒÙˆÚ†Ø±Ù‡Ø§
            future_to_info = {executor.submit(is_alive, info): info for info in config_list}
            
            for future in concurrent.futures.as_completed(future_to_info):
                info = future_to_info[future]
                if future.result(): # Ø§Ú¯Ø± Ø²Ù†Ø¯Ù‡ Ø¨ÙˆØ¯
                    c_data = ip_map.get(info['ip'], {'country': 'Unknown', 'countryCode': 'UN'})
                    flag = get_flag(c_data['countryCode'])
                    
                    # Ù†Ø§Ù…â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¨Ø¯ÙˆÙ† Ù¾ÛŒÙ†Ú¯
                    prefix = "skimia" if info['source_tag'] == 'skimia' else "smkn"
                    # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§ÛŒÙ…ÙˆØ¬ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹ Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ø±Ø§Ø­Øªâ€ŒØªØ±
                    type_emoji = "ğŸ”’" if info['score'] > 0 else "ğŸŒ"
                    new_name = f"{type_emoji}{prefix}-{c_data['countryCode']}-{flag}"
                    
                    final_uri = ""
                    if info['type'] == 'vmess':
                        info['data']['ps'] = new_name
                        new_json = json.dumps(info['data'])
                        final_uri = 'vmess://' + base64.b64encode(new_json.encode('utf-8')).decode('utf-8')
                    else:
                        base = info['raw'].split('#')[0]
                        final_uri = f"{base}#{new_name}"
                    
                    valid_configs.append({
                        'uri': final_uri,
                        'type': info['type'],
                        'country_code': c_data['countryCode'],
                        'source_tag': info['source_tag'],
                        'score': info['score'] # Ø§Ù…ØªÛŒØ§Ø² Ø§Ù…Ù†ÛŒØªÛŒ
                    })

        # --- Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯ ---
        # Ø§ÙˆÙ„ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ù…ØªÛŒØ§Ø² Ø§Ù…Ù†ÛŒØª (TLS/443)ØŒ Ø¨Ø¹Ø¯ ØªØµØ§Ø¯ÙÛŒ
        random.shuffle(valid_configs) # Ø§ÙˆÙ„ Ù…Ø®Ù„ÙˆØ· Ú©Ù† Ú©Ù‡ Ù‡Ù…ÛŒØ´Ù‡ ØªÚ©Ø±Ø§Ø±ÛŒ Ù†Ø¨Ø§Ø´Ù‡
        valid_configs.sort(key=lambda x: x['score'], reverse=True) # Ø­Ø§Ù„Ø§ Ø®ÙˆØ¨â€ŒÙ‡Ø§ Ø±Ùˆ Ø¨ÛŒØ§Ø± Ø¨Ø§Ù„Ø§

        print(f'Alive configs: {len(valid_configs)}')

        # Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ Ø°Ø®ÛŒØ±Ù‡
        categories = {'sub_best_mixed': [], 'sub_skimia': []}
        
        for conf in valid_configs:
            if conf['source_tag'] == 'skimia':
                categories['sub_skimia'].append(conf)
            
            # Ø¨Ø±Ø§ÛŒ Ù„ÛŒØ³Øª Ù…Ø®Ù„ÙˆØ· Ùˆ Ù¾Ø±ÙˆØªÚ©Ù„â€ŒÙ‡Ø§
            categories['sub_best_mixed'].append(conf)
            
            p_key = f"sub_proto_{conf['type']}"
            if p_key not in categories: categories[p_key] = []
            categories[p_key].append(conf)
            
            if conf['country_code'] and len(conf['country_code']) == 2:
                c_key = f"sub_loc_{conf['country_code']}"
                if c_key not in categories: categories[c_key] = []
                categories[c_key].append(conf)

        for name, configs in categories.items():
            if not configs: continue
            limit = LIMIT_SKIMIA if name == 'sub_skimia' else LIMIT_PUBLIC
            selected = configs[:limit]
            
            with open(f"{name}.txt", 'w', encoding='utf-8') as f:
                f.write('\n'.join([c['uri'] for c in selected]))
            print(f'Saved {name}.txt with {len(selected)} proxies')

        EOF
        
        python3 optimizer.py

    - name: Commit and Push
      run: |
        git config --global user.name "GitHub Action"
        git config --global user.email "action@github.com"
        git add sub_*.txt
        git commit -m "Updated optimized proxies" || echo "No changes to commit"
        git push
