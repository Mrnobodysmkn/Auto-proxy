name: Smart Proxy Splitter

permissions:
  contents: write

on:
  schedule:
    - cron: '0 * * * *' # Ù‡Ø± Ø³Ø§Ø¹Øª Ø§Ø¬Ø±Ø§ Ø´ÙˆØ¯
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Dependencies
      run: |
        pip install requests

    - name: Run Intelligent Splitter
      run: |
        # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø³Ø§Ø¨Ø³Ú©Ø±ÛŒÙ¾Ø´Ù† Ù‚Ø¯ÛŒÙ…ÛŒ
        rm -f sub_*.txt
        
        cat << 'EOF' > splitter.py
        import requests
        import base64
        import json
        import re
        import socket
        import time
        import concurrent.futures
        import os

        # --- ØªÙ†Ø¸ÛŒÙ…Ø§Øª ---
        SOURCES = [
            'https://chat.tawana.online/sub/tawanaproxy.txt',
            'https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/EternityAirports_sub.txt',
            'https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all_extracted_configs.txt',
        ]
        TIMEOUT = 1.5 # Ø³Ø®Øªâ€ŒÚ¯ÛŒØ±ÛŒ Ø¨ÛŒØ´ØªØ± Ø¨Ø±Ø§ÛŒ Ø³Ø±Ø¹Øª (Ø«Ø§Ù†ÛŒÙ‡)
        MAX_WORKERS = 50
        TOP_N = 10  # ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ù†ÙÛŒÚ¯ Ø¯Ø± Ù‡Ø± ÙØ§ÛŒÙ„

        # --- ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ ---
        def get_flag(country_code):
            if not country_code: return 'ğŸš©'
            return chr(127397 + ord(country_code[0])) + chr(127397 + ord(country_code[1]))

        def parse_config(config):
            try:
                if config.startswith('vmess://'):
                    b64 = config[8:]
                    padding = len(b64) % 4
                    if padding: b64 += '=' * (4 - padding)
                    decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                    data = json.loads(decoded)
                    return {'type': 'vmess', 'ip': data['add'], 'port': int(data['port']), 'data': data, 'raw': config}
                
                elif config.startswith('vless://') or config.startswith('trojan://') or config.startswith('ss://'):
                    ptype = config.split('://')[0]
                    match = re.search(r'://(?:.*@)?([\w\.-]+):(\d+)', config)
                    if match:
                        return {'type': ptype, 'ip': match.group(1), 'port': int(match.group(2)), 'raw': config}
            except:
                pass
            return None

        def check_speed(proxy_info):
            # Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† ØªØ§Ø®ÛŒØ± (Latency) Ø¨Ø± Ø­Ø³Ø¨ Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡
            try:
                start = time.time()
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(TIMEOUT)
                result = sock.connect_ex((proxy_info['ip'], proxy_info['port']))
                sock.close()
                end = time.time()
                if result == 0:
                    return (end - start) * 1000 # Latency in ms
            except:
                pass
            return None

        # --- Û±. Ø¯Ø§Ù†Ù„ÙˆØ¯ Ùˆ Ø§Ø³ØªØ®Ø±Ø§Ø¬ ---
        print('Downloading sources...')
        unique_configs = {} # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ø­Ø°Ù ØªÚ©Ø±Ø§Ø±ÛŒâ€ŒÙ‡Ø§
        
        for url in SOURCES:
            try:
                resp = requests.get(url, timeout=10)
                content = resp.text.strip()
                # ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø¯ÛŒÚ©Ø¯ Ø§Ú¯Ø± Ú©Ù„ ÙØ§ÛŒÙ„ Base64 Ø¨Ø§Ø´Ø¯
                try:
                    if not '://' in content[:50]:
                        content = base64.b64decode(content).decode('utf-8', errors='ignore')
                except: pass
                
                for line in content.splitlines():
                    line = line.strip()
                    if not line: continue
                    info = parse_config(line)
                    if info:
                        # Ú©Ù„ÛŒØ¯ ÛŒÚ©ØªØ§: ØªØ±Ú©ÛŒØ¨ Ø¢ÛŒâ€ŒÙ¾ÛŒ Ùˆ Ù¾ÙˆØ±Øª
                        key = f"{info['ip']}:{info['port']}"
                        if key not in unique_configs:
                            unique_configs[key] = info
            except Exception as e:
                print(f'Error fetching {url}: {e}')
        
        config_list = list(unique_configs.values())
        print(f'Total unique configs: {len(config_list)}')

        # --- Û². Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ± (Batch) ---
        print('Getting GeoIP info...')
        ips = list(set([c['ip'] for c in config_list]))
        ip_country_map = {}
        
        for i in range(0, len(ips), 100):
            batch = ips[i:i+100]
            try:
                resp = requests.post('http://ip-api.com/batch', json=[{'query': ip, 'fields': 'query,country,countryCode'} for ip in batch], timeout=15)
                for item in resp.json():
                    if 'country' in item:
                        ip_country_map[item['query']] = {'name': item['country'], 'code': item['countryCode']}
            except: pass

        # --- Û³. ØªØ³Øª Ø³Ø±Ø¹Øª Ùˆ Ù†Ø§Ù…â€ŒÚ¯Ø°Ø§Ø±ÛŒ ---
        print('Testing speeds...')
        valid_configs = []

        def process_one(info):
            latency = check_speed(info)
            if latency is not None:
                # Ù†Ø§Ù…â€ŒÚ¯Ø°Ø§Ø±ÛŒ
                c_data = ip_country_map.get(info['ip'], {'name': 'Unknown', 'code': 'UN'})
                flag = get_flag(c_data['code'])
                new_name = f"smkn-{c_data['code']}-{int(latency)}ms" # Ù…Ø«Ø§Ù„: smkn-DE-120ms
                
                # Ø§Ø¹Ù…Ø§Ù„ Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯
                final_uri = ""
                if info['type'] == 'vmess':
                    info['data']['ps'] = new_name
                    new_json = json.dumps(info['data'])
                    final_uri = 'vmess://' + base64.b64encode(new_json.encode('utf-8')).decode('utf-8')
                else:
                    base = info['raw'].split('#')[0]
                    final_uri = f"{base}#{new_name}"
                
                return {
                    'uri': final_uri,
                    'latency': latency,
                    'type': info['type'],
                    'country_code': c_data['code'],
                    'country_name': c_data['name']
                }
            return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            results = executor.map(process_one, config_list)
            for res in results:
                if res: valid_configs.append(res)

        # Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ú©Ù„ Ù„ÛŒØ³Øª Ø¨Ø± Ø§Ø³Ø§Ø³ Ø³Ø±Ø¹Øª (Ú©Ù…ØªØ±ÛŒÙ† Ù¾ÛŒÙ†Ú¯ Ø§ÙˆÙ„)
        valid_configs.sort(key=lambda x: x['latency'])
        print(f'Total Alive & Fast configs: {len(valid_configs)}')

        # --- Û´. Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ Ø°Ø®ÛŒØ±Ù‡ ---
        
        # Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§
        categories = {
            'sub_best_mixed': valid_configs, # Ù‡Ù…Ù‡ØŒ ÙˆÙ„ÛŒ Ù…Ø±ØªØ¨ Ø´Ø¯Ù‡
        }
        
        # ØªÙÚ©ÛŒÚ© Ø¨Ø± Ø§Ø³Ø§Ø³ Ù¾Ø±ÙˆØªÚ©Ù„
        for conf in valid_configs:
            proto_key = f"sub_proto_{conf['type']}"
            if proto_key not in categories: categories[proto_key] = []
            categories[proto_key].append(conf)
            
            # ØªÙÚ©ÛŒÚ© Ø¨Ø± Ø§Ø³Ø§Ø³ Ú©Ø´ÙˆØ± (ÙÙ‚Ø· Ø§Ú¯Ø± Ú©Ø¯ Ù…Ø¹ØªØ¨Ø± Ø¨Ø§Ø´Ø¯)
            if conf['country_code'] and len(conf['country_code']) == 2:
                country_key = f"sub_loc_{conf['country_code']}"
                if country_key not in categories: categories[country_key] = []
                categories[country_key].append(conf)

        # Ù†ÙˆØ´ØªÙ† ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ (ÙÙ‚Ø· Û±Û° ØªØ§ÛŒ Ø¨Ø±ØªØ± Ù‡Ø± Ø¯Ø³ØªÙ‡)
        generated_files = []
        for name, configs in categories.items():
            if not configs: continue
            
            # Ø¨Ø±Ø¯Ø§Ø´ØªÙ† Û±Û° ØªØ§ÛŒ Ø§ÙˆÙ„ (Ú†ÙˆÙ† Ù„ÛŒØ³Øª Ø§ØµÙ„ÛŒ Ù‚Ø¨Ù„Ø§Ù‹ Ø³ÙˆØ±Øª Ø´Ø¯Ù‡ Ø§Ø³ØªØŒ Ø§ÛŒÙ†â€ŒÙ‡Ø§ Ø¨Ù‡ØªØ±ÛŒÙ†â€ŒÙ‡Ø§ Ù‡Ø³ØªÙ†Ø¯)
            top_selection = configs[:TOP_N]
            
            filename = f"{name}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write('\n'.join([c['uri'] for c in top_selection]))
            generated_files.append(filename)
            print(f'Generated {filename} with {len(top_selection)} configs')

        EOF
        
        python3 splitter.py

    - name: Commit and Push
      run: |
        git config --global user.name "GitHub Action"
        git config --global user.email "action@github.com"
        # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ØªÙ…Ø§Ù… ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ØªÙ†ÛŒ Ú©Ù‡ Ø¨Ø§ sub_ Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
        git add sub_*.txt
        git commit -m "Update separated best proxies" || echo "No changes to commit"
        git push
