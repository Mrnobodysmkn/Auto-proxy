name: Smart Proxy Splitter with Source Tagging

permissions:
  contents: write

on:
  schedule:
    - cron: '0 * * * *' # Ù‡Ø± Ø³Ø§Ø¹Øª Ø§Ø¬Ø±Ø§ Ø´ÙˆØ¯
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Dependencies
      run: |
        pip install requests

    - name: Run Intelligent Splitter
      run: |
        # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ
        rm -f sub_*.txt
        
        cat << 'EOF' > splitter.py
        import requests
        import base64
        import json
        import re
        import socket
        import time
        import concurrent.futures

        # --- ØªÙ†Ø¸ÛŒÙ…Ø§Øª ---
        # ØªØ¹Ø±ÛŒÙ Ù…Ù†Ø§Ø¨Ø¹ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ú†Ø³Ø¨â€ŒÚ¯Ø°Ø§Ø±ÛŒ
        SOURCES = [
            {
                'url': 'https://chat.tawana.online/sub/tawanaproxy.txt',
                'tag': 'skimia'
            },
            {
                'url': 'https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/EternityAirports_sub.txt',
                'tag': 'public'
            },
            {
                'url': 'https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all_extracted_configs.txt',
                'tag': 'public'
            }
        ]
        
        TIMEOUT = 1.5 
        MAX_WORKERS = 50
        TOP_N = 10  # ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ù†ÙÛŒÚ¯ Ø¯Ø± ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¹Ù…ÙˆÙ…ÛŒ
        TOP_N_SKIMIA = 20 # ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ù†ÙÛŒÚ¯ Ø¨Ø±Ø§ÛŒ ÙØ§ÛŒÙ„ Ø§Ø³Ú©ÛŒÙ…ÛŒØ§ (Ø´Ø§ÛŒØ¯ Ø¨Ø®ÙˆØ§Ù‡ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø¨Ø§Ø´Ø¯)

        # --- ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ ---
        def get_flag(country_code):
            if not country_code: return 'ğŸš©'
            return chr(127397 + ord(country_code[0])) + chr(127397 + ord(country_code[1]))

        def parse_config(config):
            try:
                if config.startswith('vmess://'):
                    b64 = config[8:]
                    padding = len(b64) % 4
                    if padding: b64 += '=' * (4 - padding)
                    decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                    data = json.loads(decoded)
                    return {'type': 'vmess', 'ip': data['add'], 'port': int(data['port']), 'data': data, 'raw': config}
                
                elif config.startswith('vless://') or config.startswith('trojan://') or config.startswith('ss://'):
                    ptype = config.split('://')[0]
                    match = re.search(r'://(?:.*@)?([\w\.-]+):(\d+)', config)
                    if match:
                        return {'type': ptype, 'ip': match.group(1), 'port': int(match.group(2)), 'raw': config}
            except:
                pass
            return None

        def check_speed(proxy_info):
            try:
                start = time.time()
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(TIMEOUT)
                result = sock.connect_ex((proxy_info['ip'], proxy_info['port']))
                sock.close()
                end = time.time()
                if result == 0:
                    return (end - start) * 1000
            except:
                pass
            return None

        # --- Û±. Ø¯Ø§Ù†Ù„ÙˆØ¯ Ùˆ Ø¨Ø±Ú†Ø³Ø¨â€ŒÚ¯Ø°Ø§Ø±ÛŒ ---
        print('Downloading sources...')
        unique_configs = {} 
        
        for source in SOURCES:
            url = source['url']
            tag = source['tag']
            try:
                resp = requests.get(url, timeout=10)
                content = resp.text.strip()
                try:
                    if not '://' in content[:50]:
                        content = base64.b64decode(content).decode('utf-8', errors='ignore')
                except: pass
                
                for line in content.splitlines():
                    line = line.strip()
                    if not line: continue
                    info = parse_config(line)
                    if info:
                        # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ØªÚ¯ Ù…Ù†Ø¨Ø¹ Ø¨Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ù†ÙÛŒÚ¯
                        info['source_tag'] = tag
                        
                        key = f"{info['ip']}:{info['port']}"
                        if key not in unique_configs:
                            unique_configs[key] = info
                        else:
                            # Ø§Ú¯Ø± Ú©Ø§Ù†ÙÛŒÚ¯ Ù‚Ø¨Ù„Ø§ Ø¨ÙˆØ¯Ù‡ ÙˆÙ„ÛŒ Ø§Ù„Ø§Ù† Ø§Ø² Ø³ÙˆØ±Ø³ skimia Ø§ÙˆÙ…Ø¯Ù‡ØŒ ØªÚ¯Ø´ Ø±Ùˆ Ø¢Ù¾Ø¯ÛŒØª Ú©Ù†
                            if tag == 'skimia':
                                unique_configs[key]['source_tag'] = 'skimia'
                                
            except Exception as e:
                print(f'Error fetching {url}: {e}')
        
        config_list = list(unique_configs.values())
        print(f'Total unique configs: {len(config_list)}')

        # --- Û². Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ± ---
        print('Getting GeoIP info...')
        ips = list(set([c['ip'] for c in config_list]))
        ip_country_map = {}
        for i in range(0, len(ips), 100):
            batch = ips[i:i+100]
            try:
                resp = requests.post('http://ip-api.com/batch', json=[{'query': ip, 'fields': 'query,country,countryCode'} for ip in batch], timeout=15)
                for item in resp.json():
                    if 'country' in item:
                        ip_country_map[item['query']] = {'name': item['country'], 'code': item['countryCode']}
            except: pass

        # --- Û³. ØªØ³Øª Ø³Ø±Ø¹Øª Ùˆ Ù†Ø§Ù…â€ŒÚ¯Ø°Ø§Ø±ÛŒ ---
        print('Testing speeds...')
        valid_configs = []

        def process_one(info):
            latency = check_speed(info)
            if latency is not None:
                c_data = ip_country_map.get(info['ip'], {'name': 'Unknown', 'code': 'UN'})
                flag = get_flag(c_data['code'])
                # Ù†Ø§Ù…â€ŒÚ¯Ø°Ø§Ø±ÛŒ: Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù†Ø§Ù… Ù…Ù†Ø¨Ø¹ Ø§Ú¯Ø± skimia Ø¨Ø§Ø´Ø¯
                prefix = "skimia" if info['source_tag'] == 'skimia' else "smkn"
                new_name = f"{prefix}-{c_data['code']}-{int(latency)}ms"
                
                final_uri = ""
                if info['type'] == 'vmess':
                    info['data']['ps'] = new_name
                    new_json = json.dumps(info['data'])
                    final_uri = 'vmess://' + base64.b64encode(new_json.encode('utf-8')).decode('utf-8')
                else:
                    base = info['raw'].split('#')[0]
                    final_uri = f"{base}#{new_name}"
                
                return {
                    'uri': final_uri,
                    'latency': latency,
                    'type': info['type'],
                    'country_code': c_data['code'],
                    'source_tag': info['source_tag']
                }
            return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            results = executor.map(process_one, config_list)
            for res in results:
                if res: valid_configs.append(res)

        valid_configs.sort(key=lambda x: x['latency'])

        # --- Û´. Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ Ø°Ø®ÛŒØ±Ù‡ ---
        categories = {
            'sub_best_mixed': valid_configs,
            'sub_skimia': [], # Ù„ÛŒØ³Øª Ù…Ø®ØµÙˆØµ Ø§Ø³Ú©ÛŒÙ…ÛŒØ§
        }
        
        for conf in valid_configs:
            # Û±. Ø§Ú¯Ø± ØªÚ¯ Ø§Ø³Ú©ÛŒÙ…ÛŒØ§ Ø¯Ø§Ø±Ø¯ Ø¨Ù‡ Ù„ÛŒØ³Øª Ù…Ø®ØµÙˆØµØ´ Ø§Ø¶Ø§ÙÙ‡ Ø´ÙˆØ¯
            if conf['source_tag'] == 'skimia':
                categories['sub_skimia'].append(conf)

            # Û². Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¯ÛŒÚ¯Ø± (Ù¾Ø±ÙˆØªÚ©Ù„ Ùˆ Ú©Ø´ÙˆØ±)
            proto_key = f"sub_proto_{conf['type']}"
            if proto_key not in categories: categories[proto_key] = []
            categories[proto_key].append(conf)
            
            if conf['country_code'] and len(conf['country_code']) == 2:
                country_key = f"sub_loc_{conf['country_code']}"
                if country_key not in categories: categories[country_key] = []
                categories[country_key].append(conf)

        for name, configs in categories.items():
            if not configs: continue
            
            # ØªØ¹ÛŒÛŒÙ† Ø³Ù‚Ù ØªØ¹Ø¯Ø§Ø¯ (Ø¨Ø±Ø§ÛŒ ÙØ§ÛŒÙ„ Ø§Ø³Ú©ÛŒÙ…ÛŒØ§ Ø´Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø¨Ø®ÙˆØ§Ù‡ÛŒØ¯)
            limit = TOP_N_SKIMIA if name == 'sub_skimia' else TOP_N
            top_selection = configs[:limit]
            
            filename = f"{name}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write('\n'.join([c['uri'] for c in top_selection]))
            print(f'Generated {filename} with {len(top_selection)} configs')

        EOF
        
        python3 splitter.py

    - name: Commit and Push
      run: |
        git config --global user.name "GitHub Action"
        git config --global user.email "action@github.com"
        git add sub_*.txt
        git commit -m "Added dedicated skimia file" || echo "No changes to commit"
        git push
