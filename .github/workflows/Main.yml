name: Advanced Proxy Collector

permissions:
  contents: write

on:
  schedule:
    - cron: '0 * * * *' # Ø§Ø¬Ø±Ø§ Ø³Ø± Ù‡Ø± Ø³Ø§Ø¹Øª
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Dependencies
      run: |
        pip install requests

    - name: Run Collector Script
      run: |
        python3 -c "
        import requests
        import base64
        import json
        import re
        import socket
        import concurrent.futures
        from urllib.parse import urlparse, unquote

        # --- ØªÙ†Ø¸ÛŒÙ…Ø§Øª ---
        SOURCES = [
            'https://chat.tawana.online/sub/tawanaproxy.txt', # Ù„ÛŒÙ†Ú© Ø®ÙˆØ¯ØªØ§Ù†
            'https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/EternityAirports_sub.txt', # Ù…Ù†Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Û±
            'https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all_extracted_configs.txt', # Ù…Ù†Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Û²
        ]
        OUTPUT_FILE = 'sub.txt'
        TIMEOUT = 2  # Ø«Ø§Ù†ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ ØªØ³Øª Ø§ØªØµØ§Ù„
        MAX_WORKERS = 50 # ØªØ¹Ø¯Ø§Ø¯ ØªØ³Øª Ù‡Ù…Ø²Ù…Ø§Ù†

        # --- ØªØ§Ø¨Ø¹ ØªØ¨Ø¯ÛŒÙ„ Ú©Ø¯ Ú©Ø´ÙˆØ± Ø¨Ù‡ Ù¾Ø±Ú†Ù… ---
        def get_flag(country_code):
            if not country_code: return 'ğŸš©'
            return chr(127397 + ord(country_code[0])) + chr(127397 + ord(country_code[1]))

        # --- ØªØ§Ø¨Ø¹ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø² Ú©Ø§Ù†ÙÛŒÚ¯ ---
        def parse_config(config):
            try:
                if config.startswith('vmess://'):
                    b64 = config[8:]
                    # Ø§ØµÙ„Ø§Ø­ Ù¾Ø¯ÛŒÙ†Ú¯ Ø¨ÛŒØ³Û¶Û´
                    padding = len(b64) % 4
                    if padding: b64 += '=' * (4 - padding)
                    data = json.loads(base64.b64decode(b64).decode('utf-8'))
                    return {'type': 'vmess', 'ip': data['add'], 'port': int(data['port']), 'data': data}
                
                elif config.startswith('vless://') or config.startswith('trojan://'):
                    # Regex Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¢ÛŒâ€ŒÙ¾ÛŒ Ùˆ Ù¾ÙˆØ±Øª
                    match = re.search(r'://(?:.*@)?([\w\.-]+):(\d+)', config)
                    if match:
                        return {'type': config.split(':')[0], 'ip': match.group(1), 'port': int(match.group(2)), 'raw': config}
            except:
                pass
            return None

        # --- ØªØ§Ø¨Ø¹ ØªØ³Øª Ø§ØªØµØ§Ù„ ---
        def check_connection(proxy_info):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(TIMEOUT)
                result = sock.connect_ex((proxy_info['ip'], proxy_info['port']))
                sock.close()
                return result == 0
            except:
                return False

        # --- Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø§ØµÙ„ÛŒ ---
        all_configs = []
        
        # Û±. Ø¯Ø§Ù†Ù„ÙˆØ¯ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§
        print('Downloading sources...')
        raw_content = ''
        for url in SOURCES:
            try:
                resp = requests.get(url, timeout=10)
                if resp.status_code == 200:
                    # Ø§Ú¯Ø± Ø¨ÛŒØ³Û¶Û´ Ø¨ÙˆØ¯ Ø¯ÛŒÚ©Ø¯ Ú©Ù†
                    content = resp.text.strip()
                    try:
                        decoded = base64.b64decode(content).decode('utf-8')
                        if 'vmess://' in decoded or 'vless://' in decoded:
                            content = decoded
                    except:
                        pass
                    raw_content += content + '\n'
            except Exception as e:
                print(f'Error downloading {url}: {e}')

        # Û². Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§ÙˆÙ„ÛŒÙ‡
        config_lines = raw_content.splitlines()
        parsed_list = []
        unique_ips = set()

        for line in config_lines:
            line = line.strip()
            if not line: continue
            info = parse_config(line)
            if info:
                parsed_list.append(info)
                unique_ips.add(info['ip'])

        print(f'Found {len(parsed_list)} configs. Unique IPs: {len(unique_ips)}')

        # Û³. Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ (Batch)
        print('Getting GeoIP info...')
        ip_country_map = {}
        ips = list(unique_ips)
        # API Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Û±Û°Û° ØªØ§ÛŒÛŒ Ø¯Ø§Ø±Ø¯ØŒ ØªÚ©Ù‡ ØªÚ©Ù‡ Ù…ÛŒâ€ŒÙØ±Ø³ØªÛŒÙ…
        for i in range(0, len(ips), 100):
            batch = ips[i:i+100]
            try:
                resp = requests.post('http://ip-api.com/batch', json=[{'query': ip, 'fields': 'query,country,countryCode'} for ip in batch], timeout=15)
                for item in resp.json():
                    if 'country' in item:
                        ip_country_map[item['query']] = {'name': item['country'], 'code': item['countryCode']}
            except Exception as e:
                print(f'GeoIP Error: {e}')

        # Û´. ØªØ³Øª Ø³Ù„Ø§Ù…Øª Ùˆ ØªØºÛŒÛŒØ± Ù†Ø§Ù…
        print('Checking health and renaming...')
        final_configs = []

        def process_single(info):
            if check_connection(info):
                # Ø³Ø§Ø®Øª Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯
                country_data = ip_country_map.get(info['ip'], {'name': 'Unknown', 'code': 'UN'})
                flag = get_flag(country_data['code'])
                new_name = f'smkn-{country_data["name"]}-{flag}'
                
                # Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ú©Ø§Ù†ÙÛŒÚ¯
                if info['type'] == 'vmess':
                    info['data']['ps'] = new_name
                    new_json = json.dumps(info['data'])
                    new_str = 'vmess://' + base64.b64encode(new_json.encode('utf-8')).decode('utf-8')
                    return new_str
                elif info['type'] in ['vless', 'trojan']:
                    # Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ Ù†Ø§Ù… Ø¨Ø¹Ø¯ Ø§Ø² #
                    base_uri = info['raw'].split('#')[0]
                    return f'{base_uri}#{new_name}'
            return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            results = executor.map(process_single, parsed_list)
            for res in results:
                if res:
                    final_configs.append(res)

        # Ûµ. Ø°Ø®ÛŒØ±Ù‡
        print(f'Alive configs: {len(final_configs)}')
        with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
            f.write('\n'.join(final_configs))
        "

    - name: Commit and Push
      run: |
        git config --global user.name "GitHub Action"
        git config --global user.email "action@github.com"
        git add sub.txt
        git commit -m "Updated proxies with Country Flags" || echo "No changes to commit"
        git push
